## 더 알아두면 좋은 알고리즘

### 소수의 판별

- 소수란 2보다 큰 자연수 중에서 **1과 자기 자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수**를 말한다.
- 소수는 2보다 큰 자연수에 대해 정의되므로, **1은 소수에 해당하지 않는다는 특징**이 있다.
- 어떤 자연수가 주어졌을 때, 소수인지 아닌지 판별하는 가장 간단한 방법은 자연수 X를 2부터 X-1까지 나눠보는 것이다.
    
    ```java
    public static boolean isPrime(int x) {
    	for (int i = 2; i < x; i++) {
    		if (x % i == 0) {
    			return false;
    		}
    	}
    
    	return true;
    }
    ```
    
    - 해당 알고리즘의 시간 복잡도는 O(x)이다.
    - 숫자가 커지면 비효율적이다.
- 위 알고리즘을 개선해서 하나의 수가 소수인지 판별하는 알고리즘을 더 빠르게 동작하도록 변경할 수 있다.
    - 예를 들어, 16이라는 수의 약수는 다음과 같다.
        
        ```java
        1, 2, 4, 8, 16
        ```
        
    - 이 때 모든 약수에 대해서 **가운데 약수를 기준으로 하여 대칭적으로 2개씩 앞 뒤로 묶어서 곱하면 16을 만들 수 있다.**
        
        ```java
        1 x 16
        2 x 8
        4 x 4
        8 x 2
        16 x 1
        ```
        
        - 가운데 약수를 기준으로 각 등식이 대칭적인 형태를 보이는 것을 알 수 있다.
    - 따라서 우리는 특정한 자연수 X가 소수인지 확인하기 위해 **바로 가운데 약수까지만 나누어 떨어지는지 확인하면 된다.**
        - 위 예시에서는 4까지만 확인하면 된다.
        - 즉, 2, 3, 4를 확인하여 나누어 떨어지는지 확인한다.
        - 다시말해 제곱근까지만(가운데 약수까지만) 확인하면 된다.
- 개선된 알고리즘으로 소수를 판별하면 O(X^1/2)에 소수를 판별할 수 있다.
    
    ```java
    public static boolean isPrime(int x) {
    	for (int i = 2; i <= Math.sqrt(x); i++) {
    		if (x % i == 0) return false;
    	}
    
    	return true;
    }
    ```
    

### 에라토스테네스의 체

- 에라토스테네스의 체 알고리즘은 **여러 개의 수가 소수인지 아닌지를 판별할 때 사용하는 알고리즘이다.**
- N보다 작거나 같은 모든 소수를 찾을 때 사용할 수 있다.
- 에라토스테네스의 체 알고리즘의 과정은 다음과 같다.
    1. 2부터 N까지의 모든 자연수를 나열한다.
    2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다.
    3. 남은 수 중에서 i의 배수를 모두 제거한다. (i는 제거하지 않는다.)
    4. 더이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복한다.
- 매 스텝마다 남은 수중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다고 했으나, 이 때 i는 N의 제곱근까지만 증가시켜 확인하면 된다.

```java
public static int n = 1000;
public static boolean[] arr = new boolean[n + 1];

public static void main(String[] args) {
	Arrays.fill(arr, true);   // 처음엔 모든 수가 소수인 것으로 초기화

	for (int i = 2; i <= Math.sqrt(n); i++) {
		if (arr[i] = true) {
			int j = 2;
			while (i * j <= n) {
				arr[i * j] = false;
				j++;
			}
		}
	}
}
```

```java
boolean[] checkPrime = new boolean[n + 1];
int count = 0;

checkPrime[0] = false;
checkPrime[1] = false;   // 1은 소수가 아니다.

for (int i = 2; i <= n; i++) {
    checkPrime[i] = true;
}

for (int i = 2; i * i <= n; i++) {
    if (checkPrime[i]) {
        for (int j = 2 * i; j <= n; j += i) checkPrime[j] = false;
				// i * 2로 시작해서 i를 점차 더해주면 i의 배수가 만들어진다.
    }
}
```

- 에라토스테네스의 체 알고리즘의 시간 복잡도는 O(NloglogN)으로 매우 빠르다.
- 동작이 빠르기 떄문에 다수의 소수를 찾는 문제에서 유용하지만, 메모리가 많이 필요하다는 단점이 있다.
- 에라토스테네스의 체를 이용해야 되는 문제의 경우 N이 1,000,000 이내로 주어지는 경우가 많다.

### 투 포인터 (Two Pointer)

- 리스트에 순차적으로 접근해야할 때 **2개의 점의 위치를 기록하면서 처리하는 알고리즘**을 의미한다.
- 예를 들어 한 반에 학생이 40명이 있을 때, 모든 학생을 번호 순서대로 일렬로 세운 뒤 학생들을 순차적으로 지목해야할 경우를 생각해보자.
    - 한명씩 부르는 것보단 2번부터 7번까지의 학생이라고 부르는 편이 더 낫다.
    - 이처럼 리스트에 담긴 데이터에 순차적으로 접근해야할 땐 **시작점과 끝점 2개의 점으로 접근할 데이터의 범위를 표현할 수 있다.**
- 투포인터 알고리즘을 이용하여 특정한 합을 가지는 부분 연속 수열 찾기 문제를 풀 수 있다.
    - 투 포인터 알고리즘의 특징은 **2개의 변수를 이용해 리스트 상의 위치를 기록한다는 점**이다.
    - 특정한 합을 가지는 부분 연속 수열 찾기 문제에서는 **부분 연속 수열의 시작점과 끝점의 위치를 기록한다.**