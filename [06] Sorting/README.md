## 기준에 따라 데이터 정렬

### 정렬 알고리즘 개요

- 정렬(Sorting)이란 **데이터를 특정한 기준에 따라서 순서대로 나열하는 것**을 말한다.
- 정렬 알고리즘으로 데이터를 정렬하면 **이진 탐색(Binary Search)이 가능**해진다.
    - **정렬 알고리즘은 이진 탐색의 전처리 과정**이기도 하다.

### 선택 정렬

```java
public class Main {
	public static void main(String[] args) {
		int n = 10;
		int[] arr = { 7, 5, 9, 0, 3, 1, 6, 2, 4, 8 };

		for (int i = 0; i < n; i++) {
			int minIndex = i;   // 가장 작은 원소의 인덱스
			for (int j = i + 1; j < n; j++) {
				if (arr[minIndex] > arr[j]) {
					minIndex = j;
				}
			}

			int temp = arr[i];
			arr[i] = arr[minIndex];
			arr[minIndex] = temp;
		}
	}
}
```

- 데이터가 무작위로 여러 개 있을 때, **이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 반복**한다.
- 가장 원시적인 방법으로 **매번 ‘가장 작은 것’을 선택한다는 의미**에서 **선택 정렬(Selection Sort) 알고리즘**이라고 한다.
- **가장 작은 것을 선택해서 앞으로 보내는 과정을 반복해서 수행**하면, 전체 데이터의 정렬이 이루어진다.
- swap은 특정한 리스트가 주어졌을 때 두 변수의 위치를 변경하는 작업을 의미한다.

### 선택 정렬의 시간 복잡도

- 선택 정렬은 N-1번만큼 가장 작은 수를 찾아서 맨 앞으로 보내야한다.
- 또한, 매번 가장 작은 수를 찾기 위해 비교 연산이 필요하다.
- 따라서, **빅오 표기법으로 간단히 O(N^2)으로 표현할 수 있다.**
- 보통 **반복문이 얼마나 중첩되었는지를 기준으로 간단히 시간 복잡도를 판단할 수 있다.**
    - 선택 정렬은 소스 코드 상으로 간단한 형태의 이중반복문이 사용되었다.
- 선택 정렬을 이용하는 경우 데이터의 개수가 10,000개 이상이면 정렬 속도가 급격히 느려진다.
- 선택 정렬은 다른 정렬 알고리즘에 비해 매우 비효율적이다.

### 삽입 정렬

```java
public class Main {
	public static void main(String[] args) {
			int n = 10;
      int[] arr = { 7, 5, 9, 0, 3, 1, 6, 2, 4, 8 };

			for (int i = 1; i < n; i++) {
				// i가 1부터 시작하는 이유는 0번째 데이터는 정렬되어있다고 가정하기 때문
				for (int j = i; j > 0; j--) {
					// i부터 1까지 감소하며 반복한다.
					// 한 칸씩 왼쪽으로 이동
					if (arr[j] < arr[j - 1]) {   // 만약 현재 데이터가 내 앞의 데이터보다 작으면 스왑
						int temp = arr[j];
						arr[j] = arr[j - 1];
						arr[j - 1] = temp;
					} else {
						break;   // 현재 데이터가 내 앞의 데이터보다 크거나 같으므로 멈춤(정렬)
					}
				}
			}

			for (int i = 0; i < n; i++) {
				System.out.println(arr[i] + " ");
			}
		}
	}
}
```

> 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하면 어떨까?
> 
- 삽입 정렬은 선택 정렬에 비해 실행 시간 측면에서 더욱 효율적인 알고리즘이다.
- 특히 **삽입 정렬은 필요할 때만 위치를 바꾸므로, ‘데이터가 거의 정렬되어 있을 때’ 훨씬 효율적이다.**
- 선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸는 반면 삽입 정렬은 그렇지 않다.
- 삽입 정렬은 **특정한 데이터를 적절한 위치에 ‘삽입’한다는 의미에서 삽입 정렬(Insertion Sort)이라고 부른다.**
- 삽입 정렬은 **특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.**
    - 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤, 그 위치에 삽입된다는 점이 특징이다.
- 삽입 정렬은 특징이 있는데, **정렬이 이루어진 원소는 항상 오름차순을 유지하고 있다는 점이다.**
    - 이러한 특징 때문에 삽입 정렬에서는 특정한 데이터가 삽입될 위치를 선정할 때, **삽입될 데이터보다 작은 데이터를 만나면 그 위치에서 멈추면 된다.**
    - 특정한 데이터의 왼쪽에 있는 데이터들은 **이미 정렬된 상태**이므로, **자기보다 작은 데이터를 만났다면 더 이상 데이터를 살펴볼 필요도 없이 그 자리에 삽입되면 되는 것이다!**

### 삽입 정렬의 시간 복잡도

- 삽입 정렬의 시간복잡도 역시 O(N^2)
- 단, 현재 리스트의 데이터가 거의 정렬된 상태라면 매우 빠르게 동작한다.
    - 최선의 경우 O(N)
- 삽입 정렬은 비효율적이지만, 거의 정렬된 상태에서는 퀵 정렬보다 강력하다.